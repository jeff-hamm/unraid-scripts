#!/usr/bin/env zsh
# @desc Update dc-projects.conf with all docker-compose projects
#   Scans /mnt/pool/appdata/ for docker-compose.yml files
#   Extracts service names from each project

# Don't exit on error - continue scanning all projects
setopt LOCAL_OPTIONS
setopt NO_ERR_EXIT

CONF_FILE="${PHOME:-$HOME}/.conf/dc-projects.conf"
SEARCH_PATHS=(
    "/mnt/pool/appdata"
)

# Temp arrays to collect data
typeset -A projects
typeset -A project_services

echo "Scanning for docker-compose projects..."

# Find all docker-compose.yml files
for search_path in "${SEARCH_PATHS[@]}"; do
    [[ -d "$search_path" ]] || continue
    
    while IFS= read -r compose_file; do
        # Get the directory containing docker-compose.yml
        compose_dir="$(dirname "$compose_file")"
        
        # Determine project name from path
        # /mnt/pool/appdata/immich/docker/docker-compose.yml -> immich
        # /mnt/pool/appdata/jumpflix/docker-compose.yml -> jumpflix
        if [[ "$compose_dir" == */docker ]]; then
            # If it's in a docker/ subdirectory, use parent dir name
            project_name="$(basename "$(dirname "$compose_dir")")"
        else
            # Otherwise use the directory name
            project_name="$(basename "$compose_dir")"
        fi
        
        # Skip if we already found this project (prefer shortest path)
        if [[ -n "${projects[$project_name]}" ]]; then
            current_depth="${#projects[$project_name]}"
            new_depth="${#compose_dir}"
            [[ $new_depth -lt $current_depth ]] || continue
        fi
        
        projects[$project_name]="$compose_dir"
        
        # Extract service names from docker-compose.yml
        local services=()
        local yq_path="${PHOME:-$HOME}/.local/opt/bin/yq"
        if [[ -x "$yq_path" ]]; then
            # Use yq if available (faster and more reliable)
            services=($("$yq_path" eval '.services | keys | .[]' "$compose_file" 2>/dev/null))
        elif command -v yq &>/dev/null; then
            services=($(yq eval '.services | keys | .[]' "$compose_file" 2>/dev/null))
        else
            # Fallback to grep/awk parsing
            services=($(awk '/^services:/,/^[a-z]/ {
                if ($1 ~ /^[a-z][a-z0-9_-]*:$/ && $1 !~ /^services:$/) {
                    gsub(/:$/, "", $1)
                    print $1
                }
            }' "$compose_file"))
        fi
        
        if [[ ${#services[@]} -gt 0 ]]; then
            project_services[$project_name]="${(j: :)services}"
            echo "  ✓ $project_name ($compose_dir) - ${#services[@]} services"
        else
            echo "  ✓ $project_name ($compose_dir)"
        fi
        
    done < <(find "$search_path" -maxdepth 3 -name "docker-compose.yml" -o -name "docker-compose.yaml" 2>/dev/null)
done

# Generate the config file
echo ""
echo "Writing $CONF_FILE..."

cat > "$CONF_FILE" << 'EOF'
# Docker Compose project mappings
# Auto-generated by dc-update-projects
# Run 'dc-update-projects' to regenerate

EOF

# Write DC_PROJECTS array
echo "typeset -gA DC_PROJECTS" >> "$CONF_FILE"
echo "DC_PROJECTS=(" >> "$CONF_FILE"

for project_name in ${(ko)projects}; do
    printf '    %-20s "%s"\n' "$project_name" "${projects[$project_name]}" >> "$CONF_FILE"
done

echo ")" >> "$CONF_FILE"
echo "" >> "$CONF_FILE"

# Write DC_PROJECT_SERVICES array
echo "# Services in each project (for autocomplete)" >> "$CONF_FILE"
echo "typeset -gA DC_PROJECT_SERVICES" >> "$CONF_FILE"
echo "DC_PROJECT_SERVICES=(" >> "$CONF_FILE"

for project_name in ${(ko)project_services}; do
    printf '    %-20s "%s"\n' "$project_name" "${project_services[$project_name]}" >> "$CONF_FILE"
done

echo ")" >> "$CONF_FILE"

echo ""
echo "✓ Found ${#projects[@]} projects"
echo "✓ Config written to $CONF_FILE"
echo ""
echo "Reload completions with: reload-completions"
